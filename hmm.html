<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Mirror (P2P)</title>
  <meta name="color-scheme" content="dark light"/>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1622; --muted:#9aa7b4; --text:#e7eef6;
      --line:#1f2b3a; --good:#43d17a; --warn:#f3c969; --bad:#ff5c77; --accent:#7aa7ff;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --r:16px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    body{ margin:0; background:linear-gradient(120deg,#05070a,#0b0f14 40%, #070b12); color:var(--text); }
    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }
    .wrap{ max-width:1080px; padding:18px; margin:0 auto; }
    .topbar{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      position:sticky; top:0; backdrop-filter: blur(10px);
      background: rgba(11,15,20,.7); border-bottom:1px solid var(--line); z-index:10;
      padding:12px 18px;
    }
    .brand{ display:flex; gap:10px; align-items:center; }
    .logo{
      width:34px; height:34px; border-radius:10px;
      background: radial-gradient(circle at 30% 20%, #a5c7ff, #2b5cff 35%, #0c1430 70%);
      box-shadow: var(--shadow);
    }
    .brand h1{ font-size:14px; margin:0; letter-spacing:.4px; }
    .tag{ font-size:12px; color:var(--muted); }
    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .btn{
      border:1px solid var(--line); background: rgba(15,22,34,.6); color:var(--text);
      padding:10px 12px; border-radius:12px; cursor:pointer; transition:.15s;
      display:inline-flex; gap:8px; align-items:center;
    }
    .btn:hover{ transform: translateY(-1px); border-color:#2a3a52; }
    .btn.primary{ background: linear-gradient(180deg, rgba(122,167,255,.25), rgba(122,167,255,.08)); border-color: rgba(122,167,255,.35); }
    .btn.danger{ background: rgba(255,92,119,.12); border-color: rgba(255,92,119,.35); }
    .btn.good{ background: rgba(67,209,122,.12); border-color: rgba(67,209,122,.35); }
    .btn.ghost{ background: transparent; }
    .pill{ font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid var(--line); color:var(--muted); }
    .grid{ display:grid; gap:12px; grid-template-columns: 360px 1fr; align-items:start; }
    @media(max-width: 980px){ .grid{ grid-template-columns: 1fr; } }
    .card{
      background: rgba(15,22,34,.65);
      border:1px solid var(--line); border-radius: var(--r);
      box-shadow: var(--shadow);
      padding:14px;
    }
    .card h2{ margin:0 0 8px; font-size:14px; letter-spacing:.3px; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.45; }
    .hr{ height:1px; background: var(--line); margin:12px 0; }
    label{ font-size:12px; color:var(--muted); display:block; margin:10px 0 6px; }
    input, textarea, select{
      width:100%; box-sizing:border-box;
      background: rgba(5,7,10,.5);
      border:1px solid var(--line);
      color:var(--text);
      padding:10px 10px;
      border-radius: 12px;
      outline:none;
    }
    textarea{ min-height: 96px; resize: vertical; }
    .split{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media(max-width:650px){ .split{ grid-template-columns: 1fr; } }
    .kpi{ display:flex; gap:10px; flex-wrap:wrap; }
    .k{ padding:10px 12px; border-radius:14px; border:1px solid var(--line); background: rgba(5,7,10,.35); }
    .k .n{ font-size:16px; font-weight:700; }
    .k .l{ font-size:11px; color:var(--muted); }
    .list{ display:flex; flex-direction:column; gap:8px; }
    .item{
      padding:10px 10px; border-radius:14px;
      border:1px solid var(--line); background: rgba(5,7,10,.35);
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .small{ font-size:12px; color:var(--muted); }
    .badge{ font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid var(--line); }
    .bG{ border-color: rgba(67,209,122,.45); color: var(--good); background: rgba(67,209,122,.1); }
    .bY{ border-color: rgba(243,201,105,.55); color: var(--warn); background: rgba(243,201,105,.1); }
    .bR{ border-color: rgba(255,92,119,.55); color: var(--bad); background: rgba(255,92,119,.1); }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .toast{
      position:fixed; bottom:18px; left:50%; transform:translateX(-50%);
      background: rgba(15,22,34,.9); border:1px solid var(--line);
      padding:10px 12px; border-radius:12px; box-shadow: var(--shadow);
      display:none; z-index:50;
    }
    .dangerBox{ border:1px solid rgba(255,92,119,.4); background: rgba(255,92,119,.08); padding:12px; border-radius:14px; }
    .goodBox{ border:1px solid rgba(67,209,122,.35); background: rgba(67,209,122,.08); padding:12px; border-radius:14px; }
    .warnBox{ border:1px solid rgba(243,201,105,.35); background: rgba(243,201,105,.08); padding:12px; border-radius:14px; }
    .right{ text-align:right; }
    .inline{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .checkRow{ display:flex; gap:10px; flex-wrap:wrap; }
    .check{
      border:1px solid var(--line); background: rgba(5,7,10,.35);
      padding:8px 10px; border-radius: 12px; font-size:12px; color:var(--text);
      display:flex; gap:8px; align-items:center;
    }
    .check input{ width:auto; }
    .statusDot{ width:8px; height:8px; border-radius:50%; background:var(--bad); margin-right:4px; transition:background .3s; }
    .statusDot.on{ background:var(--good); }
    
    /* P2P Specific Styles */
    .pulse{ animation: pulse 2s infinite; }
    @keyframes pulse { 0%{opacity:1;} 50%{opacity:0.5;} 100%{opacity:1;} }
    .idBox { 
      background:rgba(0,0,0,0.3); border:1px dashed var(--accent); 
      padding:15px; border-radius:12px; margin:10px 0; text-align:center; cursor:pointer;
    }
    .idBox:hover { background:rgba(122,167,255,0.1); }
    .idText { font-family:monospace; font-size:18px; letter-spacing:1px; color:var(--accent); font-weight:bold; }
    
    /* Debug Console */
    #debugLog {
      background: #000; color: #0f0; font-family: monospace; font-size: 10px;
      padding: 10px; border-radius: 8px; margin-top: 15px; height: 100px;
      overflow-y: auto; white-space: pre-wrap; border: 1px solid var(--line);
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <div class="logo" id="logo"></div>
      <div>
        <h1 id="appName">Mirror</h1>
        <div class="tag" id="appTag">
          <span class="statusDot" id="statusDot"></span> P2P Mode
        </div>
      </div>
    </div>
    <div class="row">
      <span class="pill" id="vaultState">Locked</span>
      <button class="btn danger" id="quickExitBtn" title="Quick Exit (panic)"><span>â›”</span><span>Quick Exit</span></button>
      <button class="btn" id="lockBtn" style="display:none"><span>ðŸ”’</span><span>Lock</span></button>
    </div>
  </div>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <h2>Navigation</h2>
        <div class="muted" id="navHint">Start or Join a session.</div>
        <div class="hr"></div>
        <div class="list" id="nav"></div>
        <div class="hr"></div>
        <div class="muted">
          <div class="warnBox">
            <b>Privacy Note:</b> Connection is Peer-to-Peer. Data is stored ONLY on your device (Local Storage) and synced directly to your partner when connected.
          </div>
        </div>
      </div>

      <div class="card" id="main"></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<!-- PeerJS for P2P WebRTC -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<script type="module">
/** =========================================================
 * MIRROR (P2P Version)
 * - Removed Firestore completely
 * - Uses PeerJS for direct browser-to-browser sync
 * - Uses LocalStorage for data persistence
 * ========================================================= */

const $ = (sel) => document.querySelector(sel);
const el = (tag, attrs={}, children=[]) => {
  const n = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs)) {
    if (k === "class") n.className = v;
    else if (k === "html") n.innerHTML = v;
    else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2), v);
    else if (v === true) n.setAttribute(k, ""); 
    else if (v !== false && v != null) n.setAttribute(k, v);
  }
  for (const c of children) n.append(c);
  return n;
};

const toast = (msg) => {
  const t = $("#toast");
  t.textContent = msg;
  t.style.display = "block";
  clearTimeout(toast._to);
  toast._to = setTimeout(()=> t.style.display="none", 2200);
};

/* --- LOGGING --- */
function log(msg) {
  const d = $("#debugLog");
  if(d) {
    d.innerHTML += `> ${msg}\n`;
    d.scrollTop = d.scrollHeight;
  }
  console.log("[P2P]", msg);
}

/* --- STATE & STORAGE --- */
let state = {
  locked: true,
  key: null,
  salt: null,        // Current salt (Uint8Array)
  passphrase: null,  // Cached in memory for re-keying
  vault: null,
  peer: null,        
  conn: null,        
  myPeerId: null,
  view: "LOCK",
  _editingUserId: null,
  selected: { relationshipId: null, conflictId: null, activePartnerId: null }
};

/* --- CRYPTO UTILS --- */
const enc = new TextEncoder();
const dec = new TextDecoder();
function b64(bytes) { return btoa(String.fromCharCode(...bytes)); }
function unb64(str) { return Uint8Array.from(atob(str), c => c.charCodeAt(0)); }
function randBytes(n) { const a = new Uint8Array(n); crypto.getRandomValues(a); return a; }

async function deriveKeyFromSecret(secret, saltBytes) {
  const baseKey = await crypto.subtle.importKey("raw", enc.encode(secret), "PBKDF2", false, ["deriveKey"]);
  return crypto.subtle.deriveKey({ name: "PBKDF2", salt: saltBytes, iterations: 200000, hash: "SHA-256" }, baseKey, { name: "AES-GCM", length: 256 }, false, ["encrypt","decrypt"]);
}
async function encryptJson(key, obj) {
  const iv = randBytes(12);
  const ct = new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, enc.encode(JSON.stringify(obj))));
  return { ivB64: b64(iv), ctB64: b64(ct) };
}
async function decryptJson(key, payload) {
  const pt = await crypto.subtle.decrypt({name:"AES-GCM", iv: unb64(payload.ivB64)}, key, unb64(payload.ctB64));
  return JSON.parse(dec.decode(pt));
}

/* --- LOCAL STORAGE --- */
const STORAGE_KEY = "mirror_vault_data";

function loadLocalVault() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return null;
  return JSON.parse(raw);
}

function saveLocalVault(saltBytes, encryptedPayload) {
  // We store the SALT and the PAYLOAD. 
  // Passphrase is never stored.
  const storageObj = { 
    saltB64: b64(saltBytes), 
    data: encryptedPayload 
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(storageObj));
}

/* --- P2P LOGIC --- */

function initPeer(customId=null) {
  return new Promise((resolve, reject) => {
    log("Initializing Peer...");
    const id = customId || "mirror-" + Math.random().toString(36).substr(2, 6);
    
    const peer = new Peer(id, { debug: 1 });

    peer.on('open', (id) => {
      state.myPeerId = id;
      state.peer = peer;
      log("My ID: " + id);
      resolve(id);
    });

    peer.on('connection', (conn) => {
      log("Incoming connection...");
      handleConnection(conn);
    });

    peer.on('error', (err) => {
      log("Peer Error: " + err.type);
      if(err.type === 'unavailable-id') {
        initPeer(null).then(resolve); 
      }
    });
  });
}

function handleConnection(conn) {
  if (state.conn && state.conn !== conn) { conn.close(); return; }
  
  state.conn = conn;
  $("#statusDot").classList.add("on");
  toast("Connected!");
  log("Connected to " + conn.peer);

  conn.on('data', async (msg) => {
    // msg format: { saltB64, data: {ivB64, ctB64} }
    if (!msg || !msg.data || !msg.saltB64) {
      log("Recv: Invalid message format.");
      return;
    }

    log("Recv: Data payload.");
    try {
      if (!state.passphrase) { log("Ignored: Vault locked"); return; }

      let activeKey = state.key;
      let activeSalt = state.salt;
      let saltChanged = false;

      // 1. SALT CHECK
      // If incoming salt != local salt, we try to re-key using the incoming salt + our passphrase.
      // This solves the issue where User A and User B start separate vaults with the same password but different random salts.
      if (msg.saltB64 !== b64(state.salt)) {
        log("Salt mismatch. Attempting re-key...");
        const incomingSalt = unb64(msg.saltB64);
        // Try to derive key using OUR passphrase and THEIR salt
        const tempKey = await deriveKeyFromSecret(state.passphrase, incomingSalt);
        activeKey = tempKey;
        activeSalt = incomingSalt;
        saltChanged = true;
      }

      // 2. DECRYPT
      const incomingVault = await decryptJson(activeKey, msg.data);
      log("Decrypted successfully.");
      
      // 3. MERGE / UPDATE
      const incomingTime = new Date(incomingVault.updatedAt || 0).getTime();
      const localTime = new Date(state.vault.updatedAt || 0).getTime();

      log(`Time: In(${incomingTime}) vs Loc(${localTime})`);

      if (incomingTime > localTime) {
        state.vault = incomingVault;
        
        // If we changed keys to match partner, update our state permanently
        if (saltChanged) {
          state.key = activeKey;
          state.salt = activeSalt;
          log("Updated local Salt/Key to match partner.");
        }

        // Save to disk
        saveLocalVault(state.salt, msg.data);
        render();
        toast("Synced.");
        log("Synced: Local updated.");
      } else {
        log("Synced: Local is newer/same.");
      }

    } catch (e) {
      log("Decryption Failed! WRONG PASSPHRASE.");
      console.error(e);
      toast("Sync Error: Passphrase mismatch. Reset Required?");
    }
  });

  conn.on('close', () => {
    state.conn = null;
    $("#statusDot").classList.remove("on");
    log("Disconnected.");
    toast("Partner Disconnected");
  });

  const trySync = () => {
    log("Attempting initial sync...");
    setTimeout(syncData, 1000); 
  };

  if (conn.open) trySync();
  else conn.on('open', trySync);
}

function connectToPeer(partnerId) {
  if (!state.peer) return;
  log("Connecting to " + partnerId + "...");
  const conn = state.peer.connect(partnerId);
  conn.on('open', () => handleConnection(conn));
  conn.on('error', (err) => log("Conn Error: " + err));
}

async function syncData() {
  if (!state.conn) { log("Sync Fail: No connection"); return; }
  if (!state.key || !state.vault) { log("Sync Fail: Locked/No Data"); return; }
  
  log("Sending data...");
  // Use Helper to construct message
  // We send OUR salt and OUR encrypted data
  const encrypted = await encryptJson(state.key, state.vault);
  const msg = {
    saltB64: b64(state.salt),
    data: encrypted
  };
  
  state.conn.send(msg);
  // Ensure local storage is in sync
  saveLocalVault(state.salt, encrypted);
}

/* --- VAULT ACTIONS --- */

async function unlockVault(passphrase) {
  const local = loadLocalVault();
  if (!local) throw new Error("No local vault found. Create one first.");
  
  try {
    const salt = unb64(local.saltB64);
    const key = await deriveKeyFromSecret(passphrase, salt);
    // Attempt decrypt
    const vault = await decryptJson(key, local.data);
    
    // Success - Set State
    state.key = key;
    state.salt = salt;
    state.vault = vault;
    state.passphrase = passphrase; // Cache for salt-rotation support
    
    state.locked = false;
    state.view = "DASH";
    applyBranding();
    
    await initPeer();
    render();
  } catch (e) {
    console.error(e);
    throw new Error("Wrong passphrase. If you forgot it, you must Reset Vault.");
  }
}

async function createVault(passphrase) {
  const salt = randBytes(16);
  const key = await deriveKeyFromSecret(passphrase, salt);
  const vault = defaultVault();
  // Ensure fresh timestamp
  vault.updatedAt = new Date().toISOString(); 
  
  const encrypted = await encryptJson(key, vault);
  
  // Save
  saveLocalVault(salt, encrypted);
  
  // Set State
  state.key = key;
  state.salt = salt;
  state.vault = vault;
  state.passphrase = passphrase;
  
  state.locked = false;
  state.view = "DASH";
  
  applyBranding();
  await initPeer();
  render();
}

async function saveVault() {
  if (!state.key || !state.vault) return;
  state.vault.updatedAt = new Date().toISOString();
  
  // Re-encrypt everything with current key
  const encrypted = await encryptJson(state.key, state.vault);
  
  // 1. Save Local
  saveLocalVault(state.salt, encrypted);

  // 2. Send P2P
  if (state.conn) {
    const msg = {
        saltB64: b64(state.salt),
        data: encrypted
    };
    state.conn.send(msg);
    log("Auto-synced update.");
  }
}

function defaultVault() {
  return {
    version: 1, updatedAt: 0, 
    users: [], relationships: [], conflicts: [],
    settings: { stealth: false, autoLockMinutes: 10 }
  };
}

/** --- FORM HELPERS --- */
function escapeHtml(s=""){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
function input(val="", attrs={}) { return el("input", {value: val, ...attrs}); }
function textarea(val="") { const n = el("textarea",{}); n.value = val; return n; }
function select(options=[], selected=null) {
  const n = el("select",{});
  for (const o of options) {
    const opt = el("option",{value:o, html: escapeHtml(String(o))});
    if (String(o)===String(selected)) opt.selected = true;
    n.append(opt);
  }
  return n;
}
function formRow(labelText, node, extra={}) {
  const wrap = el("div",{});
  wrap.append(el("label",{html: escapeHtml(labelText)}));
  if (extra.labels && node.tagName==="SELECT") {
    node.innerHTML="";
    for (const it of extra.labels) {
      const opt = el("option",{value:it.value, html: escapeHtml(it.label)});
      if (node.value===it.value) opt.selected = true;
      node.append(opt);
    }
  }
  wrap.append(node);
  return wrap;
}

/* --- UI VIEWS --- */
function render() {
  const nav = $("#nav"); nav.innerHTML = "";
  if (state.locked) {
    $("#navHint").textContent = "Unlock to use the app.";
    nav.append(navItem("Vault Access", "LOCK", false));
  } else {
    $("#navHint").textContent = state.conn ? "Status: Connected" : "Status: Waiting for partner...";
    $("#vaultState").textContent = "Unlocked"; $("#vaultState").className = "pill";
    $("#lockBtn").style.display = "inline-flex";
    nav.append(navItem("Dashboard","DASH"), navItem("Users","USERS"), navItem("Relationships","RELS"), navItem("New Conflict","NEW_CONFLICT"), navItem("History","HISTORY"), navItem("Settings","SETTINGS"));
  }
  const main = $("#main"); main.innerHTML = "";
  const v = state.view;
  if(v==="LOCK") main.append(renderLock());
  else if(v==="DASH") main.append(renderDash());
  else if(v==="USERS") main.append(renderUsers());
  else if(v==="NEW_USER") main.append(renderNewUser());
  else if(v==="RELS") main.append(renderRels());
  else if(v==="NEW_REL") main.append(renderNewRel());
  else if(v==="NEW_CONFLICT") main.append(renderNewConflict());
  else if(v==="INTAKE") main.append(renderIntake());
  else if(v==="REPORT") main.append(renderReport());
  else if(v==="HISTORY") main.append(renderHistory());
  else if(v==="SETTINGS") main.append(renderSettings());
  else if(v==="SAFETY") main.append(renderSafety());
  else main.append(el("div",{class:"muted", html:"Unknown view."}));
  applyBranding();
}

function navItem(name, view, disabled) { return el("button", { class:"btn", style:"width:100%; justify-content:space-between", disabled: !!disabled, onclick:()=>go(view) }, [el("span", { html: `<span>${name}</span>` })]); }
function go(v){ state.view=v; render(); }

function uid(prefix="id") { return `${prefix}_${Math.random().toString(16).slice(2)}_${Date.now().toString(16)}`; }

/* --- COMPONENTS --- */
function renderLock() {
  const hasLocal = !!loadLocalVault();
  const pass = el("input",{type:"password", placeholder:"Shared Passphrase (Must match partner)"});
  
  const content = [
    el("h2",{html:"Vault Access"}),
    el("div",{class:"muted", html: hasLocal 
      ? "Local data found. Enter your Shared Passphrase to unlock." 
      : "No local data. Create a new vault.<br><span style='color:var(--warn)'>Important: Use the EXACT same passphrase as your partner.</span>"}),
    el("label",{html:"Passphrase"}), pass,
    el("div",{class:"hr"}),
    el("button",{class:"btn primary", onclick:async()=>{
      const p=pass.value;
      if(!p) return toast("Passphrase required");
      try { 
        if(hasLocal) await unlockVault(p);
        else await createVault(p);
      } catch(e){ toast(e.message); }
    }},[el("span",{html: hasLocal ? "Unlock" : "Create New Vault"})]),
    el("div",{style:"margin-top:20px; text-align:center"},[
        el("button",{class:"btn danger small", onclick:()=>{
            if(confirm("Are you sure? This will delete your local data. Do this if you forgot your passphrase or want to start fresh with a partner.")){
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
        }},[el("span",{html:"Reset Vault (Clear Data)"})])
    ])
  ];
  return el("div",{}, content);
}

function renderDash() {
  const copyId = () => {
    navigator.clipboard.writeText(state.myPeerId).then(()=>toast("ID Copied!"));
  };
  
  const partnerInput = input("", {placeholder:"Partner's Peer ID"});
  
  const connectSection = state.conn 
    ? el("div",{class:"goodBox"},[
        el("span",{html:"âœ… Connected to Partner"}),
        el("button",{class:"btn ghost small", style:"margin-left:auto", onclick:syncData},[el("span",{html:"Push Data"})])
      ])
    : el("div",{},[
        el("div",{class:"muted"},[el("span",{html:"Share this ID with your partner:"})]),
        el("div",{class:"idBox", onclick:copyId},[el("div",{class:"idText", html: state.myPeerId || "Loading..."})]),
        el("div",{class:"hr"}),
        el("div",{class:"muted"},[el("span",{html:"Or enter their ID:"})]),
        el("div",{class:"row"},[
          partnerInput,
          el("button",{class:"btn primary", onclick:()=>connectToPeer(partnerInput.value.trim())},[el("span",{html:"Connect"})])
        ])
      ]);

  return el("div",{},[
    el("h2",{html:"Dashboard"}),
    connectSection,
    el("div",{class:"hr"}),
    el("div",{class:"row"},[
      el("button",{class:"btn primary", onclick:()=>go("NEW_CONFLICT")},[el("span",{html:"Start Conflict"})]),
      el("button",{class:"btn", onclick:()=>go("USERS")},[el("span",{html:"Users"})])
    ]),
    el("div",{id:"debugLog"}) // Debug Log Container
  ]);
}

function renderUsers() {
  return el("div",{},[
    el("h2",{html:"Users"}),
    el("button",{class:"btn primary", onclick:()=>{state._editingUserId=null; go("NEW_USER");}},[el("span",{html:"Add User"})]),
    el("div",{class:"hr"}),
    el("div",{class:"list"}, state.vault.users.map(u => el("div",{class:"item"},[
      el("div",{html:`<b>${u.displayName}</b> <span class="small">${u.pronouns||""}</span>`}),
      el("div",{class:"inline"},[
        el("button",{class:"btn", onclick:()=>{state._editingUserId=u.id; go("NEW_USER");}},[el("span",{html:"Edit"})]),
        el("button",{class:"btn danger", onclick:async()=>{
          if(confirm("Delete user?")){ state.vault.users=state.vault.users.filter(x=>x.id!==u.id); await saveVault(); render(); }
        }},[el("span",{html:"Del"})])
      ])
    ])))
  ]);
}

function renderNewUser() {
  const v = state.vault;
  const editingId = state._editingUserId || null;
  const existing = editingId ? v.users.find(u=>u.id===editingId) : null;

  const f = {
    displayName: input(existing?.displayName || ""),
    pronouns: input(existing?.pronouns || ""),
    genderIdentity: input(existing?.genderIdentity || ""),
    sexualOrientation: input(existing?.sexualOrientation || ""),
    age: input(existing?.age || ""),
    location: input(existing?.location || ""),
    culture: input(existing?.cultureBackground || ""),
    religion: input(existing?.religionSpirituality || ""),
    languages: input((existing?.languages||[]).join(", ")),
    attachment: select(["secure","anxious","avoidant","disorganized"], existing?.attachmentStyle || "secure"),
    conflictStyle: select(["fight","flight","freeze","fawn"], existing?.conflictStyle || "fight"),
    outness: select(["not out","partially out","out to friends","out to family","out at work","fully out"], existing?.outnessLevel || "partially out"),
    stressors: textarea(existing?.currentStressors || ""),
    triggers: textarea((existing?.triggers||[]).join("\n")),
    coreBeliefs: textarea((existing?.coreBeliefs||[]).join("\n")),
  };

  return el("div",{},[
    el("h2",{html: existing ? "Edit User" : "New User"}),
    el("div",{class:"muted", html:"Context helps interpret conflict realistically."}),
    el("div",{class:"hr"}),
    formRow("Display name", f.displayName),
    formRow("Pronouns", f.pronouns),
    el("div",{class:"split"},[formRow("Gender ID", f.genderIdentity), formRow("Orientation", f.sexualOrientation)]),
    el("div",{class:"split"},[formRow("Age", f.age), formRow("Location", f.location)]),
    formRow("Cultural background", f.culture),
    formRow("Religion/Spirituality", f.religion),
    formRow("Languages", f.languages),
    el("div",{class:"split"},[formRow("Attachment", f.attachment), formRow("Conflict Style", f.conflictStyle)]),
    formRow("Outness Level", f.outness),
    formRow("Current Stressors", f.stressors),
    formRow("Trigger Library (one/line)", f.triggers),
    formRow("Core Beliefs (one/line)", f.coreBeliefs),
    el("div",{class:"hr"}),
    el("button",{class:"btn primary", onclick:async()=>{
      const u = {
        id: existing?.id || uid("user"),
        displayName: f.displayName.value.trim() || "Unnamed",
        pronouns: f.pronouns.value.trim(),
        genderIdentity: f.genderIdentity.value.trim(),
        sexualOrientation: f.sexualOrientation.value.trim(),
        age: f.age.value.trim(),
        location: f.location.value.trim(),
        cultureBackground: f.culture.value.trim(),
        religionSpirituality: f.religion.value.trim(),
        languages: f.languages.value.split(",").map(s=>s.trim()).filter(Boolean),
        attachmentStyle: f.attachment.value,
        conflictStyle: f.conflictStyle.value,
        outnessLevel: f.outness.value,
        currentStressors: f.stressors.value.trim(),
        triggers: f.triggers.value.split("\n").map(s=>s.trim()).filter(Boolean),
        coreBeliefs: f.coreBeliefs.value.split("\n").map(s=>s.trim()).filter(Boolean),
        createdAt: existing?.createdAt || new Date().toISOString()
      };
      if (existing) {
        const idx = v.users.findIndex(x=>x.id===existing.id);
        v.users[idx] = u;
      } else {
        v.users.push(u);
      }
      state._editingUserId = null;
      await saveVault();
      go("USERS");
      toast("Saved User.");
    }},[el("span",{html:"Save User"})]),
    el("button",{class:"btn", onclick:()=>{state._editingUserId=null; go("USERS");}},[el("span",{html:"Cancel"})])
  ]);
}

function renderRels() {
  return el("div",{},[
    el("h2",{html:"Relationships"}),
    el("button",{class:"btn primary", onclick:()=>go("NEW_REL")},[el("span",{html:"Create Relationship"})]),
    el("div",{class:"hr"}),
    el("div",{class:"list"}, state.vault.relationships.map(r => el("div",{class:"item"},[
      el("div",{html:`<b>${r.name}</b>`}),
      el("button",{class:"btn good", onclick:()=>{ state.selected.relationshipId = r.id; toast("Selected"); render(); }},[el("span",{html:"Select"})])
    ])))
  ]);
}

function renderNewRel() {
  if (state.vault.users.length < 2) return el("div",{class:"warnBox", html:"Need 2 users first."});
  const name = input(), s1 = select(state.vault.users.map(u=>u.id)), s2 = select(state.vault.users.map(u=>u.id));
  [s1,s2].forEach(s => { s.innerHTML=""; state.vault.users.forEach(u => s.append(el("option",{value:u.id, html:u.displayName}))); });
  
  return el("div",{},[
    el("h2",{html:"New Relationship"}),
    formRow("Name", name), formRow("Partner 1", s1), formRow("Partner 2", s2),
    el("div",{class:"hr"}),
    el("button",{class:"btn primary", onclick:async()=>{
      if(s1.value === s2.value) return toast("Different partners required");
      state.vault.relationships.push({ id: uid("r"), name: name.value, memberIds:[s1.value, s2.value], createdAt: new Date().toISOString() });
      await saveVault(); go("RELS");
    }},[el("span",{html:"Save"})]),
    el("button",{class:"btn", onclick:()=>go("RELS")},[el("span",{html:"Cancel"})])
  ]);
}

function renderNewConflict() {
  const r = state.vault.relationships.find(x => x.id === state.selected.relationshipId);
  if (!r) return el("div",{class:"warnBox", html:"Select a relationship first."});
  return el("div",{},[
    el("h2",{html:"New Conflict"}), el("div",{class:"muted", html:`For: ${r.name}`}), el("div",{class:"hr"}),
    el("button",{class:"btn primary", onclick:async()=>{
      const cid = uid("c");
      state.vault.conflicts.push({ id: cid, relationshipId: r.id, createdAt: new Date().toISOString(), partnerIntakes: {} });
      state.selected.conflictId = cid; state.selected.activePartnerId = r.memberIds[0];
      await saveVault(); go("INTAKE");
    }},[el("span",{html:"Start Intake"})])
  ]);
}

function renderIntake() {
  const c = state.vault.conflicts.find(x=>x.id===state.selected.conflictId);
  const u = state.vault.users.find(x=>x.id===state.selected.activePartnerId);
  if(!c || !u) return go("DASH");
  const existing = c.partnerIntakes[u.id] || {};
  const facts = textarea(existing.facts||""), thoughts = textarea(existing.thoughts||"");
  
  const behaviorKeys = ["insults","threatLeaving","weaponizedVuln","outingThreat","followedAndCornered"];
  const behDiv = el("div",{class:"checkRow"}, behaviorKeys.map(k => {
    const chk = el("input",{type:"checkbox"}); if(existing.behaviors?.[k]) chk.checked = true;
    const d = el("div",{class:"check"},[chk, el("span",{html:k})]); d._key = k; return d;
  }));

  return el("div",{},[
    el("h2",{html:`Intake: ${u.displayName}`}),
    formRow("Facts (Camera check)", facts), formRow("Thoughts/Interpretations", thoughts),
    el("label",{html:"Red Flags (Check if present)"}), behDiv,
    el("div",{class:"hr"}),
    el("button",{class:"btn primary", onclick:async()=>{
      const behs = {}; behDiv.querySelectorAll(".check").forEach(d => { if(d.querySelector("input").checked) behs[d._key] = true; });
      c.partnerIntakes[u.id] = { facts: facts.value, thoughts: thoughts.value, behaviors: behs, emotions: existing.emotions||[], fairnessAreas: existing.fairnessAreas||[] };
      await saveVault();
      
      const r = state.vault.relationships.find(x=>x.id===c.relationshipId);
      if (r.memberIds.indexOf(u.id) === 0) { state.selected.activePartnerId = r.memberIds[1]; go("INTAKE"); }
      else { c.analysis = { createdAt: new Date().toISOString(), coupleSummary: { headline:"Analysis Pending", neutralFacts:"..." }, perPartner: {}, bluntTruths:[], boundaryTips:[] }; await saveVault(); go("REPORT"); }
    }},[el("span",{html:"Save & Continue"})]),
    el("button",{class:"btn", onclick:()=>go("DASH")},[el("span",{html:"Cancel"})])
  ]);
}

function renderReport() { return el("div",{},[el("h2",{html:"Report"}), el("div",{class:"goodBox", html:"Analysis Saved."}), el("div",{class:"hr"}), el("button",{class:"btn", onclick:()=>go("DASH")},[el("span",{html:"Done"})])]); }
function renderHistory() { return el("div",{},[el("h2",{html:"History"}), el("div",{class:"list"}, state.vault.conflicts.map(c => el("div",{class:"item"},[el("div",{html:`Conflict: ${new Date(c.createdAt).toLocaleDateString()}`}), el("button",{class:"btn", onclick:()=>{state.selected.conflictId=c.id; go("REPORT");}},[el("span",{html:"View"})])])))]); }
function renderSettings() { return el("div",{},[el("h2",{html:"Settings"}), el("div",{class:"muted", html:"P2P Mode Active. Data saved locally."})]); }
function renderSafety() { return el("div",{},[el("h2",{html:"Safety Pivot"}), el("div",{class:"dangerBox", html:"Safety signals detected."}), el("button",{class:"btn", onclick:()=>go("DASH")},[el("span",{html:"Exit"})])]); }

function makeFaviconDataURI(type="normal") {
  const c = type==="stealth" ? ["#111827","#9aa7b4"] : ["#2b5cff","#ffffff"];
  return "data:image/svg+xml;base64," + btoa(`<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" fill="${c[0]}" rx="16"/><circle cx="32" cy="32" r="12" fill="${c[1]}"/></svg>`);
}
function applyBranding() {
  $("#appName").textContent = "Mirror"; $("#appTag").innerHTML = '<span class="statusDot" id="statusDot"></span> P2P Enabled.';
  let l=document.querySelector('link[rel="icon"]'); if(!l){l=document.createElement("link");l.rel="icon";document.head.appendChild(l);}
  l.href=makeFaviconDataURI();
}

$("#quickExitBtn").addEventListener("click", ()=>window.location.href="https://www.bbc.co.uk/weather");
render();
</script>
</body>
</html>